Block I Apollo Guidance Computer (AGC4) assembler version 1.2

First pass: generate symbol table.
Second pass: generate object code.

                          ; WAITLIST demonstration (file:waitdemo.asm) 
                          ; 
                          ; Version: 1.0 
                          ; Author: John Pultorak 
                          ; Date: 11/03/2001 
                          ; 
                          ; PURPOSE: 
                          ; AGC WAITLIST demonstration program. 
                          ; 
                          ; OPERATION: 
                          ; TBD. 
                          ; 
                          ; ERRATA: 
                          ; - Written for the AGC4R assembler. The assembler directives and syntax 
                          ; differ somewhat from the original AGC assembler. 
                          ; - No special effort was made to optimize the algorithms or memory usage. 
                          ; 
                          ; SOURCES: 
                          ; Information on the Block 1 architecture: instruction set, instruction 
                          ; sequences, registers, register transfers, control pulses, memory and 
                          ; memory addressing, I/O assignments, interrupts, and involuntary counters 
                          ; was obtained from: 
                          ; 
                          ; A. Hopkins, R. Alonso, and H. Blair-Smith, "Logical Description 
                          ; for the Apollo Guidance Computer (AGC4)", R-393, 
                          ; MIT Instrumentation Laboratory, Cambridge, MA, Mar. 1963. 
                          ; 
                          ; Supplementary information was obtained from: 
                          ; 
                          ; R. Alonso, J. H. Laning, Jr. and H. Blair-Smith, "Preliminary 
                          ; MOD 3C Programmer's Manual", E-1077, MIT Instrumentation 
                          ; Laboratory, Cambridge, MA, Nov. 1961. 
                          ; 
                          ; B. I. Savage and A. Drake, "AGC4 Basic Training Manual, Volume I", 
                          ; E-2052, MIT Instrumentation Laboratory, Cambridge, 
                          ; MA, Jan. 1967. 
                          ; 
                          ; E. C. Hall, "MIT's Role in Project Apollo, Volume III, Computer 
                          ; Subsystem", R-700, MIT Charles Stark Draper Laboratory, 
                          ; Cambridge, MA, Aug. 1972. 
                          ; 
                          ; A. Hopkins, "Guidance Computer Design, Part VI", source unknown. 
                          ; 
                          ; A. I. Green and J. J. Rocchio, "Keyboard and Display System Program 
                          ; for AGC (Program Sunrise)", E-1574, MIT Instrumentation 
                          ; Laboratory, Cambridge, MA, Aug. 1964. 
                          ; 
                          ; E, C. Hall, "Journey to the Moon: The History of the Apollo 
                          ; Guidance Computer", AIAA, Reston VA, 1996. 
                          ; 
                          
                          ; ---------------------------------------------- 
                          
                                         ORG      EXTENDER       
05777    5777     47777 0                DS       %47777         ; needed for EXTEND 
                          
                          ; ============================================== 
                          ; ERASEABLE MEMORY: 
                          
                                         ORG      %100           ; start of data area 
                          
                          ; WAITLIST data area ------------------------------- 
                          ; 
                          MAXTASK        EQU      7              ; max number of tasks 
                          MAXVAL         EQU      %037777        ; largest pos 15-bit int (+16383 decimal) 
                          MAXDELAY       EQU      12000          ; 120 seconds (in .01 sec ticks) 
                          MAXTIMEOUT     EQU      MAXVAL-MAXDELAY+1 ; TIME3 setting for MAXDELAY 
                          
                          
                          ; task delta t: number of 10 mSec ticks until timeout. 
                          ; i.e.: 0=timeout, 1=10mS until timeout, 2=20mS until timeout... 
                          
                          ; task record structure 
                          TSKTIME        EQU      0              ; offset to task delta time 
                          TSKADDR        EQU      1              ; offset to 14-bit task address 
                          
                          TRECSZ         EQU      2              ; size of task record (words) 
                          
                          ; Array of all task records 
                          WL_taskList    EQU      *              
00100    0100     27340 0                DS       MAXDELAY       ; record 0 
00101    0101     00000 1                DS       0              
                          
00102    0102     27340 0                DS       MAXDELAY       ; record 1 
00103    0103     00000 1                DS       0              
                          
00104    0104     27340 0                DS       MAXDELAY       ; record 2 
00105    0105     00000 1                DS       0              
                          
00106    0106     27340 0                DS       MAXDELAY       ; record 3 
00107    0107     00000 1                DS       0              
                          
00110    0110     27340 0                DS       MAXDELAY       ; record 4 
00111    0111     00000 1                DS       0              
                          
00112    0112     27340 0                DS       MAXDELAY       ; record 5 
00113    0113     00000 1                DS       0              
                          
00114    0114     27340 0                DS       MAXDELAY       ; record 6 
00115    0115     00000 1                DS       0              
                          
                          
00116    0116     00000 1 WL_IN_saveQ    DS       0              ; return address 
00117    0117     00000 1 WL_IN_taskPtr  DS       0              ; points to task rec in list 
00120    0120     00000 1 WL_IN_loopCnt  DS       0              ; loop counter 
                          
00121    0121     00000 1 WL_AT_saveQ    DS       0              ; return address 
00122    0122     00000 1 WL_AT_taskPtr  DS       0              ; points to task rec in list 
00123    0123     00000 1 WL_AT_newTime  DS       0              ; time to be inserted 
00124    0124     00000 1 WL_AT_timeLeft DS       0              ; time remaining until timeout 
00125    0125     00000 1 WL_AT_loopCnt  DS       0              ; loop counter 
                          
00126    0126     00000 1 WL_T3_saveQ    DS       0              ; return address 
                          
00127    0127     00000 1 WL_ST_saveQ    DS       0              ; return address 
00130    0130     00000 1 WL_ST_taskPtr  DS       0              ; points to task rec in list 
00131    0131     00000 1 WL_ST_newTime  DS       0              ; time-out time 
00132    0132     00000 1 WL_ST_loopCnt  DS       0              ; loop counter 
                          
00133    0133     00000 1 WL_RT_saveQ    DS       0              ; return address 
00134    0134     00000 1 WL_RT_runAddr  DS       0              ; address of task to run 
                          
00135    0135     00000 1 WL_RM_saveQ    DS       0              ; return address 
00136    0136     00000 1 WL_RM_taskPtr  DS       0              ; points to task rec in list 
00137    0137     00000 1 WL_RM_taskPtr2 DS       0              ; points to task rec behind taskPtr 
00140    0140     00000 1 WL_RM_loopCnt  DS       0              ; loop counter 
00141    0141     00000 1 WL_RM_retval   DS       0              ; tmp store for return value 
                          
00142    0142     00000 1 WL_IS_newTime  DS       0              ; INPUT: time to be inserted 
00143    0143     00000 1 WL_IS_newAddr  DS       0              ; INPUT: address to be inserted 
00144    0144     00000 1 WL_IS_saveQ    DS       0              ; return address 
00145    0145     00000 1 WL_IS_taskPtr  DS       0              ; points to task rec in list 
00146    0146     00000 1 WL_IS_taskPtr2 DS       0              ; points to task rec ahead of taskPtr 
00147    0147     00000 1 WL_IS_loopCnt  DS       0              ; loop counter 
                          
                          ; ============================================== 
                          ; FIXED MEMORY: 
                          
                          ; ---------------------------------------------- 
                          ; EXECUTION ENTRY POINTS 
                          ; ---------------------------------------------- 
                          
                          ; program (re)start 
                                         ORG      GOPROG         
02000    2000 0  1,2036 0                TC       goMAIN         
                          
                          ; interrupt service entry points 
                                         ORG      T3RUPT         
02004    2004 5  0,0026 0                TS       ARUPT          
02005    2005 3  0,0001 0                XCH      Q              
02006    2006 5  0,0027 1                TS       QRUPT          
02007    2007 0  1,2512 0                TC       goT3           
                          
                                         ORG      ERRUPT         
02010    2010 5  0,0026 0                TS       ARUPT          
02011    2011 3  0,0001 0                XCH      Q              
02012    2012 5  0,0027 1                TS       QRUPT          
02013    2013 0  1,2514 0                TC       goER           
                          
                                         ORG      DSRUPT         
02014    2014 5  0,0026 0                TS       ARUPT          
02015    2015 3  0,0001 0                XCH      Q              
02016    2016 5  0,0027 1                TS       QRUPT          
02017    2017 0  1,2515 1                TC       goDS           
                          
                                         ORG      KEYRUPT        
02020    2020 5  0,0026 0                TS       ARUPT          
02021    2021 3  0,0001 0                XCH      Q              
02022    2022 5  0,0027 1                TS       QRUPT          
02023    2023 0  1,2516 1                TC       goKEY          
                          
                          
                                         ORG      UPRUPT         
02024    2024 5  0,0026 0                TS       ARUPT          
02025    2025 3  0,0001 0                XCH      Q              
02026    2026 5  0,0027 1                TS       QRUPT          
02027    2027 0  1,2517 0                TC       goUP           
                          
                          ; ---------------------------------------------- 
                          ; FIXED MEMORY CONSTANTS (shared) 
                          ; ---------------------------------------------- 
                          
02030    2030     00200 0 ofbit          DS       %200           ; OUT1, bit 8 initiates standby 
02031    2031     00000 1 zero           DS       0              
02032    2032     00001 0 one            DS       1              
02033    2033     06000 1 bankAddr       DS       %6000          ; fixed-switchable addr range starts here 
02034    2034     01777 1 lowAddr        DS       %1777          ; mask for 10-bit address 
                          
                          ; ---------------------------------------------- 
                          ; MAIN PROGRAM 
                          ; ---------------------------------------------- 
                          
02035    2035     00050 1 time1          DS       %50            
                          
                          goMAIN         EQU      *              
02036    2036 2  0,0000 0                INHINT                  ; inhibit interrupts 
                          
                          ; first, check for standby operation. 
02037    2037 3  1,2030 0                XCH      ofbit          
02040    2040 5  0,0011 1                TS       OUT1           
                          
02041    2041 0  1,2057 1                TCR      WL_initWL      ; initialize WAITLIST 
                          
02042    2042 3  1,2035 0                CAF      time1          ; add a test task 
02043    2043 0  1,2105 1                TC       WL_addTask     
02044    2044     22000 1                DS       task1          ; 14-bit task address 
                          
02045    2045 2  0,0000 1                RELINT                  
02046    2046 0  1,2046 1 theend         TC       theend         
                          
                          ; ---------------------------------------------- 
                          ; WAITLIST constants 
                          ; ---------------------------------------------- 
                          
02047    2047     00002 0 WL_taskRecSize DS       TRECSZ         ; size of a task record (words) 
02050    2050     00100 0 WL_tskLstStart DS       WL_taskList    ; starting address for task list 
02051    2051     00114 0 WL_tskLstEnd   DS       MAXTASK-1@TRECSZ+WL_taskList 
02052    2052     00006 1 WL_numTasks    DS       MAXTASK-1      ; init loop counter for all tasks 
02053    2053     00005 1 WL_numTasks1   DS       MAXTASK-2      ; init loop counter for all tasks - 1 
                          
02054    2054     37777 1 WL_maxVal      DS       MAXVAL         
02055    2055     27340 0 WL_maxDelay    DS       MAXDELAY       
02056    2056     10440 0 WL_maxTimeOut  DS       MAXTIMEOUT     
                          
                          
                          ; ---------------------------------------------- 
                          ; WL_initWL - INITIALIZE WAITLIST 
                          ; 
                          ; Subroutine initializes the eraseable memory segment for WAITLIST. 
                          ; Necessary in case the AGC is restarted. 
                          ; 
                          ; Note: the valid range for TIME3 is 10440 to 37777 (which spans 
                          ; 12000 (base 10) ticks, which corresponds to 120 seconds) 
                          ; positive overflow occurs at 40000, which triggers T3RUPT. 
                          ; TIME3 values of 0 to 10437 are illegal; these values occur 
                          ; after timeout when the counter overflows. TIME3 values in this 
                          ; range indicate that timeout has occurred and that T3RUPT is 
                          ; presently occurring, or is pending. 
                          ; ---------------------------------------------- 
                          WL_initWL      EQU      *              
02057    2057 3  0,0001 0                XCH      Q              
02060    2060 5  0,0116 1                TS       WL_IN_saveQ    ; save return address 
                          
02061    2061 3  1,2056 0                CAF      WL_maxTimeOut  
02062    2062 5  0,0037 0                TS       TIME3          
                          
                          ; Iterate through task list and initialize all records to NIL 
                          
02063    2063 3  1,2050 0                CAF      WL_tskLstStart ; init pointer to start of list 
02064    2064 5  0,0117 0                TS       WL_IN_taskPtr  
                          
02065    2065 3  1,2052 1                CAF      WL_numTasks    ; loop for number of tasks 
                          WL_IN_loop     EQU      *              
02066    2066 5  0,0120 1                TS       WL_IN_loopCnt  
                          
02067    2067 3  1,2055 0                CAF      WL_maxDelay    
02070    2070 2  0,0117 1                INDEX    WL_IN_taskPtr  
02071    2071 5  0,0000 1                TS       TSKTIME        
                          
02072    2072 3  1,2031 1                CAF      zero           
02073    2073 2  0,0117 1                INDEX    WL_IN_taskPtr  
02074    2074 5  0,0001 0                TS       TSKADDR        
                          
02075    2075 3  0,0117 0                XCH      WL_IN_taskPtr  ; bump task pointer back 1 record 
02076    2076 6  1,2047 0                AD       WL_taskRecSize 
02077    2077 5  0,0117 0                TS       WL_IN_taskPtr  
                          
02100    2100 1  0,0120 0                CCS      WL_IN_loopCnt  ; done checking task list? 
02101    2101 0  1,2066 0                TC       WL_IN_loop     ; not yet 
                          
02102    2102 3  0,0116 1                XCH      WL_IN_saveQ    
02103    2103 5  0,0001 0                TS       Q              ; restore return address 
02104    2104 0  0,0000 0                RETURN                  
                          
                          ; ---------------------------------------------- 
                          ; WL_addTask - ADD TASK TO WAITLIST 
                          ; 
                          ; Subroutine adds a task to WL_taskList. The following conditions are 
                          ; true upon entry. 
                          ; 1) The task list is sorted so the next task for execution is at the 
                          ; front of the list. 
                          ; 2) If no tasks are currently scheduled, the task record at the front 
                          ; of the list will be NIL. 
                          ; 3) Unused (NIL) records in the task list have their time fields set to 
                          ; MAXDELAY and their address fields set to zero. 
                          ; 4) If any tasks are scheduled for execution, the time fields in the 
                          ; task records contain the remaining time AFTER timeout. The 
                          ; task scheduled for execution at timeout will have a time of zero. 
                          ; Any other tasks that execute at that time will also have a time of 
                          ; zero. Tasks that will execute some time in the future AFTER timeout 
                          ; will have nonzero times; these times indicate the additional time 
                          ; needed after the next timeout. 
                          ; 
                          ; This function can be called from from an interrupt, or from 
                          ; normal execution. 
                          ; 
                          ; A task is scheduled for execution by calling 'WL_addTask' and 
                          ; furnishing the time-out time and starting address. 
                          ; L XCH TASK_TIMEOUT ; in 10 mSec ticks 
                          ; L+1 TC WL_addTask 
                          ; L+2 DS TASK_ADDRESS ; 14-bit address 
                          ; L+3 ... execution resumes here 
                          ; 
                          ; TASK_TIMEOUT = a positive integer from 1 - MAXDELAY that specifies the delay 
                          ; in 10 mSec ticks. Maximum delay is 12000 (2 minutes). 
                          ; TASK_ADDRESS = starting address of the task (14-bit address) 
                          ; 
                          ; Tasks execute when TIME3 overflows and generates an interrupt (T3RUPT). 
                          ; Tasks terminate themselves by jumping to ENDTASK. 
                          ; TC ENDTASK 
                          ; 
                          ; Because tasks execute during an interrupt, they should be fairly short. 
                          ; Tasks can initiate longer operations by scheduling a 'job' using EXEC. 
                          ; ---------------------------------------------- 
                          
                          WL_addTask     EQU      *              
02105    2105 2  0,0000 0                INHINT                  
02106    2106 5  0,0123 1                TS       WL_AT_newTime  ; save task time 
02107    2107 3  0,0001 0                XCH      Q              
02110    2110 5  0,0121 0                TS       WL_AT_saveQ    ; save return address-1 
                          
02111    2111 3  1,2031 1                CAF      zero           
02112    2112 2  1,2051 0                INDEX    WL_tskLstEnd   
02113    2113 6  0,0001 0                AD       TSKADDR        
02114    2114 1  0,0000 0                CCS      A              ; list full? 
02115    2115 0  1,2217 1                TC       WL_AT_done     ; >0 yes, so give up 
                          
                          ; Calculate time remaining until currently scheduled time-out. 
                          
02116    2116 3  1,2031 1                CAF      zero           
02117    2117 6  0,0037 0                AD       TIME3          ; get time 
02120    2120 5  0,0124 0                TS       WL_AT_timeLeft ; save it, temporarily 
                          
                          ; Did TIME3 recently overflow? If so, we are inside T3RUPT, or T3RUPT 
                          ; is pending. TIME3 values from 0 - 10437 are not legal, so they 
                          ; indicate that an overflow has occurred. 
                          
02121    2121 4  1,2056 1                CS       WL_maxTimeOut  
02122    2122 6  0,0124 0                AD       WL_AT_timeLeft 
02123    2123 1  0,0000 0                CCS      A              ; TIME3 recently overflowed? 
02124    2124 0  1,2140 0                TC       WL_AT_noOvf    ; >0 no 
02125    2125 0  1,2140 0                TC       WL_AT_noOvf    ; +0 no 
02126    2126 0  1,2130 1                TC       *+2            ; <0 yes 
02127    2127 0  1,2140 0                TC       WL_AT_noOvf    ; -0 no 
                          
                          ; TIME3 already timed-out, so we must be inside T3RUPT, or T3RUPT 
                          ; is pending. Just add the new task to the list. No time correction 
                          ; is necessary; the epoch is NOW. 
                          
02130    2130 3  1,2031 1                CAF      zero           
02131    2131 6  0,0123 1                AD       WL_AT_newTime  
02132    2132 5  0,0142 0                TS       WL_IS_newTime  ; set time field in new task record 
                          
02133    2133 2  0,0121 1                INDEX    WL_AT_saveQ    ; indirectly address WL_AT_saveQ 
02134    2134 3  0,0000 1                CAF      0              
02135    2135 5  0,0143 1                TS       WL_IS_newAddr  ; set addr field in new task record 
                          
02136    2136 0  1,2343 1                TCR      WL_insert      ; add new task to task list 
02137    2137 0  1,2217 1                TC       WL_AT_done     
                          
                          ; TIME3 has not timed out yet. Calculate time remaining until timeout 
                          ; (timeout occurs when TIME3 overflows) 
                          
                          WL_AT_noOvf    EQU      *              
02140    2140 4  0,0124 1                CS       WL_AT_timeLeft ; get -TIME3 
02141    2141 6  1,2054 1                AD       WL_maxVal      
02142    2142 6  1,2032 1                AD       one            
02143    2143 5  0,0124 0                TS       WL_AT_timeLeft ; time left = -TIME3 + %37777 + 1 
                          
                          ; Compare that time against the timeout for the new task. 
                          
                          WL_AT_chkOrder EQU      *              
02144    2144 4  0,0123 0                CS       WL_AT_newTime  
02145    2145 6  0,0124 0                AD       WL_AT_timeLeft 
02146    2146 1  0,0000 0                CCS      A              ; compare new task to current 
02147    2147 0  1,2162 0                TC       WL_AT_mkFirst  ; >0 (make new task 1st) 
02150    2150 0  1,2152 0                TC       *+2            ; +0 
02151    2151 0  1,2152 0                TC       *+1            ; <0 
                          
                          ; The new task does not need to run before the current time-out, so 
                          ; just add it to the list. Subtract the remaining time interval from the 
                          ; new task's time, so the new task will have the same epoch as the other 
                          ; tasks on the list. 
                          
02152    2152 4  0,0124 1                CS       WL_AT_timeLeft 
02153    2153 6  0,0123 1                AD       WL_AT_newTime  ; make epoch correction 
02154    2154 5  0,0142 0                TS       WL_IS_newTime  ; set time field in new task record 
                          
02155    2155 2  0,0121 1                INDEX    WL_AT_saveQ    ; indirectly address WL_AT_saveQ 
02156    2156 3  0,0000 1                CAF      0              
02157    2157 5  0,0143 1                TS       WL_IS_newAddr  ; set addr field in new task record 
                          
02160    2160 0  1,2343 1                TCR      WL_insert      ; add new task to task list 
02161    2161 0  1,2217 1                TC       WL_AT_done     
                          
                          ; The new task needs to run prior to the current time-out. Add the time 
                          ; remaining to all tasks currently on the list to change their epoch 
                          ; to NOW. 
                          
                          WL_AT_mkFirst  EQU      *              
02162    2162 3  1,2050 0                CAF      WL_tskLstStart ; set pointer to front of list 
02163    2163 5  0,0122 0                TS       WL_AT_taskPtr  
                          
02164    2164 3  1,2052 1                CAF      WL_numTasks    ; loop for number of tasks 
                          WL_AT_loop     EQU      *              
02165    2165 5  0,0125 1                TS       WL_AT_loopCnt  
                          
02166    2166 3  1,2031 1                CAF      zero           
02167    2167 2  0,0122 1                INDEX    WL_AT_taskPtr  
02170    2170 6  0,0001 0                AD       TSKADDR        
02171    2171 1  0,0000 0                CCS      A              ; end of list? 
02172    2172 0  1,2174 1                TC       *+2            ; >0 no, so keep going 
02173    2173 0  1,2207 0                TC       WL_AT_schTsk   ; +0 yes, add the new task 
                          
02174    2174 3  1,2031 1                CAF      zero           
02175    2175 2  0,0122 1                INDEX    WL_AT_taskPtr  
02176    2176 6  0,0000 1                AD       TSKTIME        
02177    2177 6  0,0124 0                AD       WL_AT_timeLeft ; time-out = time-out + timeLeft 
02200    2200 2  0,0122 1                INDEX    WL_AT_taskPtr  
02201    2201 5  0,0000 1                TS       TSKTIME        
                          
02202    2202 3  0,0122 0                XCH      WL_AT_taskPtr  ; bump task pointer back 1 record 
02203    2203 6  1,2047 0                AD       WL_taskRecSize 
02204    2204 5  0,0122 0                TS       WL_AT_taskPtr  
                          
02205    2205 1  0,0125 0                CCS      WL_AT_loopCnt  ; done fixing the times? 
02206    2206 0  1,2165 1                TC       WL_AT_loop     ; not yet 
                          
                          ; Now that the tasks all share the same epoch, add the new task to the 
                          ; list and call the scheduler to schedule the next task. 
                          
                          WL_AT_schTsk   EQU      *              
02207    2207 3  1,2031 1                CAF      zero           
02210    2210 6  0,0123 1                AD       WL_AT_newTime  
02211    2211 5  0,0142 0                TS       WL_IS_newTime  ; set time field in new task record 
                          
02212    2212 2  0,0121 1                INDEX    WL_AT_saveQ    ; indirectly address WL_AT_saveQ 
02213    2213 3  0,0000 1                CAF      0              
02214    2214 5  0,0143 1                TS       WL_IS_newAddr  ; set addr field in new task record 
                          
02215    2215 0  1,2343 1                TCR      WL_insert      ; add new task to task list 
                          
02216    2216 0  1,2267 0                TCR      WL_schedTask   ; schedule the next task 
                          
                          WL_AT_done     EQU      *              
02217    2217 3  0,0121 0                XCH      WL_AT_saveQ    
02220    2220 6  1,2032 1                AD       one            
02221    2221 5  0,0001 0                TS       Q              ; restore return address 
02222    2222 2  0,0000 1                RELINT                  
02223    2223 0  0,0000 0                RETURN                  
                          
                          ; ---------------------------------------------- 
                          ; T3Task - T3 TIMEOUT 
                          ; 
                          ; Perform WAITLIST activities when TIME3 times-out. Called by the 
                          ; T3 interrupt handler. 
                          ; ---------------------------------------------- 
                          
                          WL_TIME3task   EQU      *              
02224    2224 3  0,0001 0                XCH      Q              
02225    2225 5  0,0126 1                TS       WL_T3_saveQ    ; save return address 
                          
                          ; Execute all timed-out tasks. 
                          
02226    2226 0  1,2233 1                TCR      WL_runTasks    
                          
                          ; Set up TIME3 to overflow at the next task's time-out. 
                          ; Adjust the time-outs for all remaining tasks. 
                          
02227    2227 0  1,2267 0                TCR      WL_schedTask   
                          
02230    2230 3  0,0126 1                XCH      WL_T3_saveQ    
02231    2231 5  0,0001 0                TS       Q              ; restore return address 
02232    2232 0  0,0000 0                RETURN                  
                          
                          ; ---------------------------------------------- 
                          ; WL_runTasks - RUN TIMED-OUT TASK(S) 
                          ; 
                          ; Runs all tasks timed-out on WL_taskList. Tasks are removed 
                          ; from the list before they are run. 
                          ; ---------------------------------------------- 
                          
                          WL_runTasks    EQU      *              
02233    2233 3  0,0001 0                XCH      Q              
02234    2234 5  0,0133 0                TS       WL_RT_saveQ    ; save return address 
                          
                          ; loop, checking the task on the front of the list. If it is 
                          ; timed out, remove it from the list and run it. 
                          
                          WL_RT_loop     EQU      *              
02235    2235 3  1,2031 1                CAF      zero           
02236    2236 2  1,2050 1                INDEX    WL_tskLstStart 
02237    2237 6  0,0000 1                AD       TSKTIME        
02240    2240 1  0,0000 0                CCS      A              ; task timed out? 
02241    2241 0  1,2264 0                TC       WL_RT_done     ; >0 no, so we are done 
02242    2242 0  1,2244 1                TC       *+2            ; +0 
02243    2243 0  1,2244 1                TC       *+1            ; <0 
                          
                          ; This task has timed out, so run it. 
                          
02244    2244 0  1,2435 1                TCR      WL_remove      ; remove task from list 
02245    2245 5  0,0134 1                TS       WL_RT_runAddr  ; save 14-bit address of task to run 
                          
                          ; The task address is always 14-bit, so check whether the address falls 
                          ; within erasable or fixed-fixed memory. If so, use it as-is; otherwise, 
                          ; set the bank register and change the address to 12-bit. 
                          
02246    2246 4  0,0000 0                COM                     ; -(14bitAddr)+%6000 
02247    2247 6  1,2033 0                AD       bankAddr       
02250    2250 1  0,0000 0                CCS      A              ; task is bank addressed? 
02251    2251 0  1,2261 0                TC       WL_RT_runIt    ; >0 no, just run it, as is 
02252    2252 0  1,2254 0                TC       *+2            ; +0 yes 
02253    2253 0  1,2254 0                TC       *+1            ; <0 yes 
                          
02254    2254 3  1,2031 1                CAF      zero           
02255    2255 6  0,0134 1                AD       WL_RT_runAddr  
02256    2256 5  0,0015 0                TS       BANK           ; set the bank 
                          
02257    2257 7  1,2034 0                MASK     lowAddr        ; get lowest 10-bits of address 
02260    2260 6  1,2033 0                AD       bankAddr       ; set bits 11,12 for fixed-switchable 
                          
                          WL_RT_runIt    EQU      *              
02261    2261 2  0,0134 0                INDEX    WL_RT_runAddr  ; apply indirect address to next instr. 
02262    2262 0  0,0000 1                TC       0              ; run the task 
                          
                          ENDTASK        EQU      *              ; task returns here 
02263    2263 0  1,2235 1                TC       WL_RT_loop     ; check next task on list 
                          
                          WL_RT_done     EQU      *              
02264    2264 3  0,0133 0                XCH      WL_RT_saveQ    
02265    2265 5  0,0001 0                TS       Q              ; restore return address 
02266    2266 0  0,0000 0                RETURN                  
                          
                          ; ---------------------------------------------- 
                          ; WL_schedTask - SCHEDULE NEXT TASK 
                          ; 
                          ; Schedule task on the front of list for the next time-out. Adjust the 
                          ; time-out for all other tasks on the list, so they contain the remaining 
                          ; time after the next timeout. 
                          ; ---------------------------------------------- 
                          
                          WL_schedTask   EQU      *              
02267    2267 3  0,0001 0                XCH      Q              
02270    2270 5  0,0127 0                TS       WL_ST_saveQ    ; save return address 
                          
02271    2271 3  1,2031 1                CAF      zero           
02272    2272 2  1,2050 1                INDEX    WL_tskLstStart 
02273    2273 6  0,0001 0                AD       TSKADDR        
02274    2274 1  0,0000 0                CCS      A              ; task scheduled? 
02275    2275 0  1,2277 1                TC       *+2            ; >0 yes 
02276    2276 0  1,2336 0                TC       WL_ST_noTask   ; +0 no, so we are done 
                          
02277    2277 3  1,2031 1                CAF      zero           
02300    2300 2  1,2050 1                INDEX    WL_tskLstStart 
02301    2301 6  0,0000 1                AD       TSKTIME        
02302    2302 5  0,0131 1                TS       WL_ST_newTime  ; save the new task's time-out 
                          
                          ; Iterate through all tasks on the list. Subtract the time-out time 
                          ; from each task. (The 1st task on the list will now have a time-out 
                          ; of zero) 
                          
02303    2303 3  1,2050 0                CAF      WL_tskLstStart ; set pointer to front of list 
02304    2304 5  0,0130 0                TS       WL_ST_taskPtr  
                          
02305    2305 3  1,2052 1                CAF      WL_numTasks    ; loop for number of tasks 
                          WL_ST_loop     EQU      *              
02306    2306 5  0,0132 1                TS       WL_ST_loopCnt  
                          
02307    2307 3  1,2031 1                CAF      zero           
02310    2310 2  0,0130 1                INDEX    WL_ST_taskPtr  
02311    2311 6  0,0001 0                AD       TSKADDR        
02312    2312 1  0,0000 0                CCS      A              ; end of list? 
02313    2313 0  1,2315 1                TC       *+2            ; >0 no, so keep going 
02314    2314 0  1,2331 1                TC       WL_ST_setT3    ; +0 yes, set TIME3 
                          
02315    2315 3  1,2031 1                CAF      zero           
02316    2316 2  0,0130 1                INDEX    WL_ST_taskPtr  
02317    2317 6  0,0000 1                AD       TSKTIME        
02320    2320 2  0,0000 1                EXTEND                  
02321    2321 6  0,0131 1                SU       WL_ST_newTime  ; time-out = time-out - newtime 
02322    2322 2  0,0130 1                INDEX    WL_ST_taskPtr  
02323    2323 5  0,0000 1                TS       TSKTIME        
                          
02324    2324 3  0,0130 0                XCH      WL_ST_taskPtr  ; bump task pointer back 1 record 
02325    2325 6  1,2047 0                AD       WL_taskRecSize 
02326    2326 5  0,0130 0                TS       WL_ST_taskPtr  
                          
02327    2327 1  0,0132 0                CCS      WL_ST_loopCnt  ; done fixing the times? 
02330    2330 0  1,2306 0                TC       WL_ST_loop     ; not yet 
                          
                          ; Set TIME3 to overflow at the time-out of the task on the front 
                          ; of the list: TIME3 = %37777 - WL_ST_newTime + 1 
                          
                          WL_ST_setT3    EQU      *              
02331    2331 4  0,0131 0                CS       WL_ST_newTime  
02332    2332 6  1,2054 1                AD       WL_maxVal      
02333    2333 6  1,2032 1                AD       one            
02334    2334 5  0,0037 0                TS       TIME3          ; overflow at new time-out time 
02335    2335 0  1,2340 1                TC       WL_ST_done     
                          
                          WL_ST_noTask   EQU      *              
02336    2336 3  1,2056 0                CAF      WL_maxTimeOut  
02337    2337 5  0,0037 0                TS       TIME3          ; nothing scheduled, reset the clock 
                          
                          WL_ST_done     EQU      *              
02340    2340 3  0,0127 0                XCH      WL_ST_saveQ    
02341    2341 5  0,0001 0                TS       Q              ; restore return address 
02342    2342 0  0,0000 0                RETURN                  
                          
                          ; ---------------------------------------------- 
                          ; WL_insert - INSERT TASK INTO SORTED LIST 
                          ; 
                          ; Insert a task record into the sorted list. Use 'WL_IS_newTime' and 
                                         :        'WL_IS_newAddr' to set the fields of record to be inserted. 
                          ; Performs an insertion sort, with the records sorted by time. 
                          ; Lowest times are at the front of the list. If several records 
                          ; have the same time, the records inserted first will appear first 
                          ; in the list. NIL records have a time of NOTASK and a address 
                          ; of positive zero. 
                          ; ---------------------------------------------- 
                          
                          WL_insert      EQU      *              
02343    2343 3  0,0001 0                XCH      Q              
02344    2344 5  0,0144 0                TS       WL_IS_saveQ    ; save return address 
                          
02345    2345 3  1,2051 1                CAF      WL_tskLstEnd   ; set pointer to back of list 
02346    2346 5  0,0145 1                TS       WL_IS_taskPtr  
                          
02347    2347 2  0,0000 1                EXTEND                  
02350    2350 6  1,2047 0                SU       WL_taskRecSize ; set pointer to rec in front of it 
02351    2351 5  0,0146 1                TS       WL_IS_taskPtr2 
                          
02352    2352 3  1,2031 1                CAF      zero           
02353    2353 2  0,0145 0                INDEX    WL_IS_taskPtr  
02354    2354 6  0,0001 0                AD       TSKADDR        
02355    2355 1  0,0000 0                CCS      A              ; list full? 
02356    2356 0  1,2432 0                TC       WL_IS_done     ; >0 yes 
                          
                          ; Work from the back of the list to the front, pushing each record 
                          ; to the back until the insertion point is found. 
                          
02357    2357 3  1,2053 0                CAF      WL_numTasks1   ; loop for number of tasks minus 1 
                          WL_IS_loop     EQU      *              
02360    2360 5  0,0147 0                TS       WL_IS_loopCnt  
                          
02361    2361 3  1,2031 1                CAF      zero           
02362    2362 2  0,0146 0                INDEX    WL_IS_taskPtr2 
02363    2363 6  0,0001 0                AD       TSKADDR        
02364    2364 1  0,0000 0                CCS      A              ; previous record is NIL? 
02365    2365 0  1,2367 1                TC       *+2            ; no, so check it 
02366    2366 0  1,2411 1                TC       WL_IS_bumpPtr  ; yes, so skip to next record 
                          
                          
                          ; Is this the insertion point? 
                          
02367    2367 4  0,0142 1                CS       WL_IS_newTime  
02370    2370 2  0,0146 0                INDEX    WL_IS_taskPtr2 
02371    2371 6  0,0000 1                AD       TSKTIME        
02372    2372 1  0,0000 0                CCS      A              ; found insertion point? 
02373    2373 0  1,2377 0                TC       *+4            ; >0 no, keep checking 
02374    2374 0  1,2422 1                TC       WL_IS_insRec   ; +0 yes 
02375    2375 0  1,2422 1                TC       WL_IS_insRec   ; <0 yes 
02376    2376 0  1,2422 1                TC       WL_IS_insRec   ; -0 yes 
                          
                          ; No, bump the record toward the back of the list. 
                          
02377    2377 3  1,2031 1                CAF      zero           
02400    2400 2  0,0146 0                INDEX    WL_IS_taskPtr2 
02401    2401 6  0,0000 1                AD       TSKTIME        
02402    2402 2  0,0145 0                INDEX    WL_IS_taskPtr  
02403    2403 5  0,0000 1                TS       TSKTIME        ; copy time field 
                          
02404    2404 3  1,2031 1                CAF      zero           
02405    2405 2  0,0146 0                INDEX    WL_IS_taskPtr2 
02406    2406 6  0,0001 0                AD       TSKADDR        
02407    2407 2  0,0145 0                INDEX    WL_IS_taskPtr  
02410    2410 5  0,0001 0                TS       TSKADDR        ; copy address field 
                          
                          WL_IS_bumpPtr  EQU      *              
02411    2411 3  0,0145 1                XCH      WL_IS_taskPtr  ; bump task pointer forward 1 record 
02412    2412 2  0,0000 1                EXTEND                  
02413    2413 6  1,2047 0                SU       WL_taskRecSize 
02414    2414 5  0,0145 1                TS       WL_IS_taskPtr  
                          
02415    2415 2  0,0000 1                EXTEND                  
02416    2416 6  1,2047 0                SU       WL_taskRecSize ; set pointer to record in front of it 
02417    2417 5  0,0146 1                TS       WL_IS_taskPtr2 
                          
02420    2420 1  0,0147 1                CCS      WL_IS_loopCnt  ; done bumping tasks backward? 
02421    2421 0  1,2360 0                TC       WL_IS_loop     ; not yet 
                          
                          ; Insert new record. 
                          
                          WL_IS_insRec   EQU      *              
02422    2422 3  1,2031 1                CAF      zero           
02423    2423 6  0,0142 0                AD       WL_IS_newTime  
02424    2424 2  0,0145 0                INDEX    WL_IS_taskPtr  
02425    2425 5  0,0000 1                TS       TSKTIME        ; set time field 
                          
02426    2426 3  1,2031 1                CAF      zero           
02427    2427 6  0,0143 1                AD       WL_IS_newAddr  
02430    2430 2  0,0145 0                INDEX    WL_IS_taskPtr  
02431    2431 5  0,0001 0                TS       TSKADDR        ; set address field 
                          
                          WL_IS_done     EQU      *              
02432    2432 3  0,0144 0                XCH      WL_IS_saveQ    
02433    2433 5  0,0001 0                TS       Q              ; restore return address 
02434    2434 0  0,0000 0                RETURN                  
                          
                          ; ---------------------------------------------- 
                          ; WL_remove - REMOVE TASK FROM FRONT OF LIST 
                          ; 
                          ; Returns the address of the task in register A. If the list is 
                          ; empty, it returns zero in A. If a task is removed from the list, 
                          ; the remaining tasks are moved up to the front. 
                          ; ---------------------------------------------- 
                          
                          WL_remove      EQU      *              
02435    2435 3  0,0001 0                XCH      Q              
02436    2436 5  0,0135 0                TS       WL_RM_saveQ    ; save return address 
                          
02437    2437 3  1,2050 0                CAF      WL_tskLstStart ; set pointer to front of list 
02440    2440 5  0,0136 0                TS       WL_RM_taskPtr  
                          
02441    2441 6  1,2047 0                AD       WL_taskRecSize ; set pointer to next rec behind it 
02442    2442 5  0,0137 1                TS       WL_RM_taskPtr2 
                          
                          ; Save the address of record at the front of the list. 
                          
02443    2443 3  1,2031 1                CAF      zero           
02444    2444 2  0,0136 1                INDEX    WL_RM_taskPtr  
02445    2445 6  0,0001 0                AD       TSKADDR        
02446    2446 5  0,0141 0                TS       WL_RM_retval   ; get address of 1st task 
                          
02447    2447 1  0,0000 0                CCS      A              ; list empty? 
02450    2450 0  1,2452 0                TC       *+2            ; >0, no 
02451    2451 0  1,2506 0                TC       WL_RM_done     ; +0, yes, so exit 
                          
                          ; Loop through the remaining records in the task list and 
                          ; bubble them up to the front. 
                          
02452    2452 3  1,2053 0                CAF      WL_numTasks1   ; loop for number of tasks minus 1 
                          WL_RM_loop     EQU      *              
02453    2453 5  0,0140 1                TS       WL_RM_loopCnt  
                          
02454    2454 3  1,2031 1                CAF      zero           
02455    2455 2  0,0137 0                INDEX    WL_RM_taskPtr2 
02456    2456 6  0,0000 1                AD       TSKTIME        
02457    2457 2  0,0136 1                INDEX    WL_RM_taskPtr  
02460    2460 5  0,0000 1                TS       TSKTIME        ; copy time field 
                          
02461    2461 3  1,2031 1                CAF      zero           
02462    2462 2  0,0137 0                INDEX    WL_RM_taskPtr2 
02463    2463 6  0,0001 0                AD       TSKADDR        
02464    2464 2  0,0136 1                INDEX    WL_RM_taskPtr  
02465    2465 5  0,0001 0                TS       TSKADDR        ; copy address field 
                          
02466    2466 1  0,0000 0                CCS      A              ; remainder of list empty? 
02467    2467 0  1,2471 1                TC       *+2            ; >0, no 
02470    2470 0  1,2506 0                TC       WL_RM_done     ; +0, yes, so exit 
                          
02471    2471 3  0,0136 0                XCH      WL_RM_taskPtr  ; bump task pointer back 1 record 
02472    2472 6  1,2047 0                AD       WL_taskRecSize 
02473    2473 5  0,0136 0                TS       WL_RM_taskPtr  
                          
02474    2474 6  1,2047 0                AD       WL_taskRecSize ; set pointer to record behind it 
02475    2475 5  0,0137 1                TS       WL_RM_taskPtr2 
                          
02476    2476 1  0,0140 0                CCS      WL_RM_loopCnt  ; done bumping tasks upward? 
02477    2477 0  1,2453 1                TC       WL_RM_loop     ; not yet 
                          
                          ; Since we removed a record, the last record on the list 
                          ; should be NIL. 
                          
02500    2500 3  1,2055 0                CAF      WL_maxDelay    
02501    2501 2  0,0136 1                INDEX    WL_RM_taskPtr  
02502    2502 5  0,0000 1                TS       TSKTIME        ; set time field to NIL 
                          
02503    2503 3  1,2031 1                CAF      zero           
02504    2504 2  0,0136 1                INDEX    WL_RM_taskPtr  
02505    2505 5  0,0001 0                TS       TSKADDR        ; set address field to NIL 
                          
                          WL_RM_done     EQU      *              
02506    2506 3  0,0135 0                XCH      WL_RM_saveQ    
02507    2507 5  0,0001 0                TS       Q              ; restore return address 
02510    2510 3  0,0141 0                XCH      WL_RM_retval   ; return task address in A 
02511    2511 0  0,0000 0                RETURN                  
                          
                          ; ---------------------------------------------- 
                          ; RUPT (INTERRUPT) SERVICE ROUTINES 
                          ; ---------------------------------------------- 
                          
                          goT3           EQU      *              
02512    2512 0  1,2224 1                TCR      WL_TIME3task   ; handle WAITLIST interrupt 
02513    2513 0  1,2520 1                TC       endRUPT        
                          
                          goER           EQU      *              
02514    2514 0  1,2520 1                TC       endRUPT        
                          
                          goDS           EQU      *              
02515    2515 0  1,2520 1                TC       endRUPT        
                          
                          goKEY          EQU      *              
02516    2516 0  1,2520 1                TC       endRUPT        
                          
                          goUP           EQU      *              
02517    2517 0  1,2520 1                TC       endRUPT        
                          
                          
                          endRUPT        EQU      *              
02520    2520 3  0,0027 1                XCH      QRUPT          ; restore Q 
02521    2521 5  0,0001 0                TS       Q              
02522    2522 3  0,0026 0                XCH      ARUPT          ; restore A 
02523    2523 2  0,0000 1                RESUME                  ; finished, go back 
                          
                          ; ---------------------------------------------- 
                          ; ---------------------------------------------- 
                          ; TEST TASKS 
                          TADDR1         EQU      %50            
                          TADDR2         EQU      %51            
                          TADDR3         EQU      %52            
                          TADDR4         EQU      %53            
                          TADDR5         EQU      %54            
                          TADDR6         EQU      %55            
                          TADDR7         EQU      %56            
                          
                                         ORG      %22000         
                          ;taskval DS 0 
                          
                          ; TEST CODE - TASK 1 
                          task1          EQU      *              
22000 11,0000 3  0,0050 1                XCH      TADDR1         
22001 11,0001 6  1,2032 1                AD       one            
22002 11,0002 5  0,0050 1                TS       TADDR1         
                          ;TS taskval ; ********** this doesn't work 
                          
22003 11,0003 3  1,2035 0                CAF      time1          
22004 11,0004 0  1,2105 1                TC       WL_addTask     
22005 11,0005     22000 1                DS       task1          
                          
22006 11,0006 0  1,2263 1                TC       ENDTASK        

Assembly complete. Errors = 0

Symbol table:
EXTENDER       005777   MAXTASK        000007   MAXVAL         037777   
MAXDELAY       027340   MAXTIMEOUT     010440   TSKTIME        000000   
TSKADDR        000001   TRECSZ         000002   WL_taskList    000100   
WL_IN_saveQ    000116   WL_IN_taskPtr  000117   WL_IN_loopCnt  000120   
WL_AT_saveQ    000121   WL_AT_taskPtr  000122   WL_AT_newTime  000123   
WL_AT_timeLeft 000124   WL_AT_loopCnt  000125   WL_T3_saveQ    000126   
WL_ST_saveQ    000127   WL_ST_taskPtr  000130   WL_ST_newTime  000131   
WL_ST_loopCnt  000132   WL_RT_saveQ    000133   WL_RT_runAddr  000134   
WL_RM_saveQ    000135   WL_RM_taskPtr  000136   WL_RM_taskPtr2 000137   
WL_RM_loopCnt  000140   WL_RM_retval   000141   WL_IS_newTime  000142   
WL_IS_newAddr  000143   WL_IS_saveQ    000144   WL_IS_taskPtr  000145   
WL_IS_taskPtr2 000146   WL_IS_loopCnt  000147   GOPROG         002000   
T3RUPT         002004   ERRUPT         002010   DSRUPT         002014   
KEYRUPT        002020   UPRUPT         002024   ofbit          002030   
zero           002031   one            002032   bankAddr       002033   
lowAddr        002034   time1          002035   goMAIN         002036   
theend         002046   WL_taskRecSize 002047   WL_tskLstStart 002050   
WL_tskLstEnd   002051   WL_numTasks    002052   WL_numTasks1   002053   
WL_maxVal      002054   WL_maxDelay    002055   WL_maxTimeOut  002056   
WL_initWL      002057   WL_IN_loop     002066   WL_addTask     002105   
WL_AT_noOvf    002140   WL_AT_chkOrder 002144   WL_AT_mkFirst  002162   
WL_AT_loop     002165   WL_AT_schTsk   002207   WL_AT_done     002217   
WL_TIME3task   002224   WL_runTasks    002233   WL_RT_loop     002235   
WL_RT_runIt    002261   ENDTASK        002263   WL_RT_done     002264   
WL_schedTask   002267   WL_ST_loop     002306   WL_ST_setT3    002331   
WL_ST_noTask   002336   WL_ST_done     002340   WL_insert      002343   
WL_IS_loop     002360   WL_IS_bumpPtr  002411   WL_IS_insRec   002422   
WL_IS_done     002432   WL_remove      002435   WL_RM_loop     002453   
WL_RM_done     002506   goT3           002512   goER           002514   
goDS           002515   goKEY          002516   goUP           002517   
endRUPT        002520   TADDR1         000050   TADDR2         000051   
TADDR3         000052   TADDR4         000053   TADDR5         000054   
TADDR6         000055   TADDR7         000056   task1          022000   
ARUPT          000026   Q              000001   QRUPT          000027   
OUT1           000011   TIME3          000037   A              000000   
BANK           000015   